# -*- coding: utf-8 -*-
"""SDS_EDA-Copy1-checkpoint (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dNVhRplhbyGc1a2A4ztYQ7SCzSlfPKGI
"""

from google.colab import files
files.upload()

# Commented out IPython magic to ensure Python compatibility.
import seaborn as sns
import pandas as pd
import numpy as np
# %matplotlib inline
import matplotlib.pyplot as plt

data = pd.read_csv("googleplay.csv")

#finding missing values in dataset
sns.heatmap(data.isna())

#data cleaning and filling all missing values
category=data['Category']
genres=data['Genres']
data.drop(["Genres"],axis=1,inplace=True)
data['Rating']=data['Rating'].fillna( method ='ffill', inplace = False)
data['Reviews']=data['Reviews'].fillna(data['Reviews'].mean())
data['Size']=data['Size'].fillna(data['Size'].mode)
data['Installs']=data['Installs'].fillna(data['Installs'].mode)
data['Price']=data['Price'].fillna(data['Price'].mode)
data['Content Rating']=data['Content Rating'].fillna(method ='ffill', inplace = False)
data['Last Updated']=data['Last Updated'].fillna(data['Last Updated'].mode)
data['Current Ver']=data['Current Ver'].fillna(data['Current Ver'].mode)
data['Android Ver']=data['Android Ver'].fillna(data['Android Ver'].mode)
i=0
for i in range(0,6040):
  if data['Price'][i]=="0":
   data['Type'][i]="Free" 
  else:
   data['Type'][i]="Paid"


sns.heatmap(data.isna())

#To check for inconsistencies:
sns.boxplot(x=data['Reviews'])

sns.boxplot(x=data['Rating'])

y=[]
for i in range(0,6040):
 y.append(data['Type'][i])
#y.sort()
plt.hist(y,bins=5)

data.pivot_table(index=["Category"], aggfunc='size')

#barchart for different categories of apps
plt.figure(figsize=(20,5))
fig = sns.countplot(x=data['Category'], palette="hls")
fig.set_xticklabels(fig.get_xticklabels(),rotation=90)
plt.show(fig)



#pie chart for Free and PAid Apps
labels = df.Type.value_counts().index
colors = ["y","r"]
explode = [0,0]
sizes = df.Type.value_counts().values

# visual 
plt.figure(0,figsize = (6,7))
plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%')
plt.title('Apps According to Type',color = 'blue',fontsize = 15)
plt.show()

#Content Rating and Count
plt.figure(figsize=(6,3))
fig = sns.countplot(x=data['Content Rating'], palette="hls")
fig.set_xticklabels(fig.get_xticklabels(),rotation=90)
plt.show(fig)



#Content Rating and Reviews
fig = plt.figure(figsize=(20,5))
plt.title('Relationship between Raviews and the Content Rating',color = 'blue',fontsize = 15)
fig = sns.barplot(x='Content Rating',y='Reviews',data=data)
fig = fig.set_xticklabels(fig.get_xticklabels(),rotation=90)
plt.show(fig)

#Scatter Plot
#Category and Rating
fig = sns.catplot(x="Rating",y="Category", data=data)

#Most Popular Apps based on Ratings and Reviews
most_popular_apps = df[(df["Reviews"]>10000000) ][ (df["Rating"]>=4.5)]
plt.title('Most Popular Apps and their Category',color = 'blue',fontsize = 15)
sns.countplot(most_popular_apps["Category"])
plt.xticks(rotation=90)
plt.show()

#Types of Apps and Reviews
fig = plt.figure(figsize=(10,5))
plt.title('Type and Reviews',color = 'blue',fontsize = 15)
fig = sns.barplot(x='Type',y='Reviews',data=data)
fig = fig.set_xticklabels(fig.get_xticklabels(),rotation=90)
plt.show(fig)

# Commented out IPython magic to ensure Python compatibility.
# interactive Histogram plot for the average Rating of All the apps in the play store

import plotly
print(plotly.__version__)
# %matplotlib inline
import plotly.graph_objs as go
from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot
init_notebook_mode(connected=True)

df = [go.Histogram(
        x = data.Rating,
        xbins = {'start': 1, 'size': 0.1, 'end' :5}
)]

print('Average app rating = ', np.mean(data['Rating']))
plotly.offline.iplot(df, filename='overall_rating_distribution')



#Boxplot for Top 5 Categories with the most number of Apps
df=pd.DataFrame(data)
print(df.Category.value_counts().sort_values(ascending=False).nlargest(5))

df_family = df[df.Category=='FAMILY']
df_game = df[df.Category=='GAME']
df_tools = df[df.Category=='TOOLS']
df_business = df[df.Category=='BUSINESS']
df_medical = df[df.Category=='MEDICAL']

box1 = go.Box(
                y= df_family.Rating,
                name= 'Family',
                marker = dict(color = 'rgb(12, 128, 128)'))
box2 = go.Box(
                y= df_game.Rating,
                name= 'Game',
                marker = dict(color = 'rgb(100, 12, 38)'))
box3 = go.Box(
                y= df_tools.Rating,
                name= 'Tools',
                marker = dict(color = 'rgb(12, 128, 128)'))
box4 = go.Box(
                y= df_business.Rating,
                name= 'Business',
                marker = dict(color = 'rgb(50, 40, 100)'))
box5 = go.Box(
                y= df_medical.Rating,
                name= 'Medical',
                marker = dict(color = 'rgb(45, 179, 66)'))

data_boxes = [box1,box2,box3,box4,box5]
configure_plotly_browser_state()
iplot(data_boxes)



import numpy as np
np.mean(data.loc[:,['Rating']]) #mean of Rating column

np.var(data.loc[:,['Rating']]) #variance of Rating column

np.mean(data.loc[:,['Reviews']]) #mean of Reviews column

np.var(data.loc[:,['Reviews']]) #variance of Reviews column

#coverting to numpy array
from sklearn import preprocessing
x = data[["Rating"]].values
x

#normalization of rating column
min_max_scaler = preprocessing.MinMaxScaler()
x_scaled = min_max_scaler.fit_transform(x)
df_rating = pd.DataFrame(x_scaled)
df_rating

#minimum of rating after normalization
df_rating.min()

#maximum of rating after normalization
df_rating.max()

#mean of rating
np.mean(df_rating)

#variance of rating
np.var(df_rating)

#coverting to numpy array
x = data[["Reviews"]].values
x

#normalization of review column
min_max_scaler = preprocessing.MinMaxScaler()
x_scaled = min_max_scaler.fit_transform(x)
df_review = pd.DataFrame(x_scaled)
df_review

#minimum of review after normalization
df_review.min()

#maximum of review after normalization
df_review.max()

#mean of review
np.mean(df_review)

#variance of review
np.var(df_review)

#fitting the data with new mean and standard deviation
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
scaler.fit(data[["Rating","Reviews"]])

#standardization of Rating column
from sklearn import preprocessing
rating = data.loc[:,["Rating"]]
x = rating.values.astype(float)
x_scaled_rating = preprocessing.scale(x)
x_scaled_rating

#mean when rating is standardized which is 0
x_scaled_rating.mean(axis=0)

#variance when rating is standardized which is 1
x_scaled_rating.var(axis=0)

#standardization of Reviews column
review = data.loc[:,["Reviews"]]
x = review.values.astype(float)
x_scaled_review = preprocessing.scale(x)
x_scaled_review

#mean when reviews is standardized which is 0
x_scaled_review.mean(axis=0)

#variance when reviews is standardized which is 1
x_scaled_review.var(axis=0)

#The DataFrame after standardization of numeric columns
import pandas as pd
standard = data.loc[:,["Rating","Reviews"]]
x = standard.values.astype(float)
x_scaled = preprocessing.scale(data[["Rating","Reviews"]])
standardized = pd.DataFrame(x_scaled)
standardized

# Commented out IPython magic to ensure Python compatibility.
#normality check using normal probabilty plot
# %matplotlib inline
import matplotlib.pyplot as plt
from scipy.stats import norm
def normality_check(data):
    pos = []
    th_Q = []
    data = np.sort(np.array(data))
    pos = [(i-0.5)/len(data) for i in range(1,len(data)+1)]
    th_Q = [norm.ppf(i, np.mean(data), np.std(data,ddof = 1)) for i in pos]
    plt.plot(data,th_Q,'ro',data,data)
    plt.show()

#normality check using histogram and normal probability plot for reviews column
plt.hist(data.Reviews,bins = 15)
plt.show()
normality_check(data.Reviews)

#normality check using histogram and normal probability plot for rating column
plt.hist(data.Rating,bins = 15)
plt.show()
normality_check(data.Rating)

#normlaity check using qq plot for rating column
import numpy as np
import statsmodels.api as sm
import pylab as py
sm.qqplot(data["Rating"],line='s')
py.show()

#normlaity check using qq plot for reviews column
sm.qqplot(data["Reviews"],line='s')
py.show()

#total columns of this dataset
data.columns

data=data[['App', 'Category', 'Rating', 'Reviews', 'Size', 'Installs', 'Type',
       'Price', 'Content Rating', 'Last Updated', 'Current Ver',
       'Android Ver']]
data.head()

#finding the correlation
data.loc[data['Size'] == 'Varies with device'].shape
unwanted = data.loc[data['Size'] == 'Varies with device']
unwanted.shape
data.drop(unwanted.index,inplace = True)

#Remove them inorder to convert the size column to numerics
data['Size'] = data['Size'].apply(lambda x: str(x).replace('M',''))
data['Size'] = data['Size'].apply(lambda x: str(x).replace('k',''))
data['Size'] = data['Size'].apply(lambda x: str(x).replace('+',''))

#Converting Size column to numerics
data['Size'] = pd.to_numeric(data['Size'],errors='coerce')
res = data.groupby('Category')['Size'].sum().reset_index()
finaldata = res.sort_values('Size', ascending=False).reset_index(drop=True)

data['Installs'] = data['Installs'].apply(lambda x: str(x).replace('+',''))


#Converting Installs column to numerics
data['Installs'] = pd.to_numeric(data['Installs'],errors='coerce')
res = data.groupby('Category')['Installs'].sum().reset_index()
finaldata = res.sort_values('Installs', ascending=False).reset_index(drop=True)

data['Type'] = data['Type'].apply(lambda x: str(x).replace('Free','0'))
data['Type'] = data['Type'].apply(lambda x: str(x).replace('Paid','1'))


#Converting Type column to numerics
data['Type'] = pd.to_numeric(data['Type'],errors='coerce')
res = data.groupby('Category')['Type'].sum().reset_index()
finaldata = res.sort_values('Type', ascending=False).reset_index(drop=True)


#Converting Size column to numerics
data['Price'] = data['Price'].apply(lambda x: str(x).replace('$',''))
data['Price'] = pd.to_numeric(data['Price'],errors='coerce')
res = data.groupby('Category')['Price'].sum().reset_index()
finaldata = res.sort_values('Price', ascending=False).reset_index(drop=True)

data.corr()

#correlation using heatmap 
plt.figure(figsize=(10,10))
plt.title('Correlation Heatmap',color = 'blue',fontsize = 15)
sns.heatmap(data.corr(), annot=True, cmap="coolwarm")
plt.show()

